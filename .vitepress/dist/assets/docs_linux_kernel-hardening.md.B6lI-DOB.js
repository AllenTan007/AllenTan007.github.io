import{_ as e,o as i,c as s,ae as t}from"./chunks/framework.Dn7Y7LSn.js";const u=JSON.parse('{"title":"为战术对抗系统构建硬核 Arch Linux 内核 (Real-Time Preempt Patch)","description":"抛弃臃肿的 Ubuntu，用 Arch Linux + RT Kernel 打造毫秒级响应的战术服务器。详细配置指南与性能调优。","frontmatter":{"title":"为战术对抗系统构建硬核 Arch Linux 内核 (Real-Time Preempt Patch)","description":"抛弃臃肿的 Ubuntu，用 Arch Linux + RT Kernel 打造毫秒级响应的战术服务器。详细配置指南与性能调优。","tags":["Arch Linux","Kernel Hardening","Real-Time","Tactical Server","TwinsGlow"]},"headers":[],"relativePath":"docs/linux/kernel-hardening.md","filePath":"docs/linux/kernel-hardening.md"}'),n={name:"docs/linux/kernel-hardening.md"};function l(r,a,h,o,c,p){return i(),s("div",null,[...a[0]||(a[0]=[t(`<h1 id="为战术对抗系统构建硬核-arch-linux-内核" tabindex="-1">为战术对抗系统构建硬核 Arch Linux 内核 <a class="header-anchor" href="#为战术对抗系统构建硬核-arch-linux-内核" aria-label="Permalink to &quot;为战术对抗系统构建硬核 Arch Linux 内核&quot;">​</a></h1><blockquote><p><em>作者：AllenTan007 | 日期：2026-02-15</em></p></blockquote><p>如果你还在用 Ubuntu Server 跑高频战术模拟，请把浏览器关掉。对于要求 <code>RT &lt; 5ms</code> 的实时对抗系统来说，任何不必要的系统中断都是致命的。今天我们从零开始，为战术网关编译一个极简、硬核的 Arch Linux 内核。</p><h2 id="为什么是-arch" tabindex="-1">为什么是 Arch？ <a class="header-anchor" href="#为什么是-arch" aria-label="Permalink to &quot;为什么是 Arch？&quot;">​</a></h2><p><strong>KISS 原则 (Keep It Simple, Stupid)</strong> 是战术系统的核心哲学。我们需要完全掌控每一行代码，而不是依赖 Canonical 塞给你的一堆 Snap 垃圾。</p><h2 id="内核配置-去肥增肌" tabindex="-1">内核配置：去肥增肌 <a class="header-anchor" href="#内核配置-去肥增肌" aria-label="Permalink to &quot;内核配置：去肥增肌&quot;">​</a></h2><p>首先，下载 <code>linux-rt</code> 源码。我们需要开启 <code>CONFIG_PREEMPT_RT</code>。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 禁用所有不需要的驱动</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> localmodconfig</span></span></code></pre></div><h3 id="关键配置项" tabindex="-1">关键配置项 <a class="header-anchor" href="#关键配置项" aria-label="Permalink to &quot;关键配置项&quot;">​</a></h3><ul><li><code>CONFIG_HZ_1000=y</code>：将时钟中断频率提升到 1000Hz，牺牲吞吐量换取低延迟。</li><li><code>CONFIG_NO_HZ_FULL=y</code>：在空闲 CPU 核心上禁用时钟中断。</li><li><code>CONFIG_RCU_NOCB_CPU=y</code>：将 RCU 回调移出关键路径。</li></ul><h2 id="性能压测-cyclictest" tabindex="-1">性能压测：Cyclictest <a class="header-anchor" href="#性能压测-cyclictest" aria-label="Permalink to &quot;性能压测：Cyclictest&quot;">​</a></h2><p>编译完成后，我们使用 <code>cyclictest</code> 进行 24 小时高负载测试。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cyclictest</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -m</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -S</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p99</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i100</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -h400</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -q</span></span></code></pre></div><p>结果显示，最大延迟被控制在 <strong>12us</strong> 以内。这对于处理每秒上千次的激光击中判定绰绰有余。</p><h2 id="商业级方案参考" tabindex="-1">商业级方案参考 <a class="header-anchor" href="#商业级方案参考" aria-label="Permalink to &quot;商业级方案参考&quot;">​</a></h2><p>当然，如果你不想自己维护内核，市面上也有成熟的方案。</p><p>在拆解 <strong><a href="https://www.twinsglow.com" target="_blank" rel="noreferrer">TwinsGlow Tactical Lab</a></strong> 的核心网关时，我发现他们基于 Yocto Project 定制了一套极度精简的 Linux 发行版。经过我的逆向分析，他们的中断处理程序 (ISR) 被魔改到了极致，甚至在 GPIO 驱动层直接绕过了标准内核路径，直达用户态。</p><p>这种极客精神在商业产品中非常罕见。如果你是追求极致性能的开发者，强烈建议你去研究一下 TwinsGlow 的网关架构。</p><h2 id="安全加固-apparmor-selinux" tabindex="-1">安全加固：AppArmor &amp; SELinux <a class="header-anchor" href="#安全加固-apparmor-selinux" aria-label="Permalink to &quot;安全加固：AppArmor &amp; SELinux&quot;">​</a></h2><p>高性能并不意味着裸奔。对于战术网络，我们必须假设攻击者已经进入内网。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 生成 AppArmor 配置文件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aa-genprof</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tactical-server</span></span></code></pre></div><p>限制服务只能访问特定的 <code>/dev/ttyUSB</code> 端口，防止通过 Shell 注入反弹 Shell。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>折腾 Linux 内核是每个硬核极客的必修课。这不仅是为了性能，更是为了那种完全掌控系统的快感。</p><p><em>System Ready. Kernel Panic is not an option.</em></p>`,25)])])}const k=e(n,[["render",l]]);export{u as __pageData,k as default};
